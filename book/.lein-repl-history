(take 10 (lib-fibo))
(doc lib-fibo)
(class (take 10 (lib-fibo)))
(use :reload 'testing)
(metadate #'seq)
(metadata #'seq)
(find-doc meta)
(find-doc "meta")
(meta #'seq)
(source seq)
(class (seq 1 2 3))
(class (seq [1 2 3]))
(class (lib-fibo))
(use :reload 'testing)
(meta #'lib-fibo)
(use :reload 'testing)
(meta #'lib-fibo)
(source seq)
(doc lib-fibo)
(nth (lib-fibo) 100000)
(source take)
(doc when)
(doc when-let)
(doc pos?)
(nth 100000 (lazy-fibo))
(nth (lazy-fibo) 100000)
(take 100 (fibo))
(take 100 (lazy-fibo))
(map (fn [s] (take (dec (count s)) s) (take 100 (lazy-fibo))))
(map (fn [s] (take (dec (count s)))) (take 100 (lazy-fibo)))
(take 5 15213_
)
(take 5 15213)
(take 5 "15213")
(doc set!)
(def fibo (lib-fibo))
(take 10 fibo)
(doc fibs)
(doc lazy-cat)
(macroexpand ('lazy-cat [1 2] [3 4]))
(macroexpand '(lazy-cat [1 2] [3 4]))
(require '[examples.introduction :as intro])
(source intro/fibs)
(nth intro/fibs 100000)
(use :reload 'testing)
(count-head-pairs {:h :h :t :t :h})
(count-head-pairs #{:h :h :t :t :h})
(count-head-pairs [:h :h :t :t :h])
(use :reload 'testing)
(count-head-pairs [:h :h :t :t :h])
(use :reload 'testing)
(count-head-pairs [:h :h :t :t :h])
(use :reload 'testing)
(count-head-pairs [:h :h :t :t :h])
(count-head-pairs [:h :h :t :t :h :h])
(doc second)
(doc third)
(doc next)
(first nil)
(= nil nil)
(doc fist)
(doc first)
(defn nothing [] ())
(nothing)
(defn nothing [] )
(nothing)
(doc lazy-seq)
(doc partition)
(use :reload 'testing)
(better-count-head-pairs [:h :h :t :t :h :h])
(better-count-head-pairs [:h :h :t :t :h :h :h])
(doc def)
(doc defn)
(doc empty?)
(use :reload 'testing)
(macroexpand #'clojure-source?)
(macroexpand clojure-source?)
(macroexpand (clojure-source?))
(macroexpand '(defn clojure-source?
  "Returns true if file is Clojure source code."
  [file]
  (.endsWith (.toString file) ".clj")))
(doc clojure-source?)
(def {:doc "A thing} a 10)
)
(def ^{:doc "A thing} a 10)
(def ^{:doc "A thing"} a 10)
(doc a)
(def {:doc "A thing"} a 10)
(def ^{:doc "A thing"} a 10)
(def a "A thing" {:tag Long} 10)
(def a "A thing" 10)
(doc a)
(doc def)
(macroexpand '(def ^{:doc "Count items matching a filter"}
count-if (comp count filter)))
(doc comment)
(macroexpand '(comment asdfsadf))
(macroexpand '(comment asfsadf))
(macroexpand '(comment asfsadf asdf))
(macroexpand '))
(macroexpand '())
(macroexpand '(asdf))
(macroexpand '(comment))
(macroexpand '(commen))
(doc def)
(doc comp)
((comp count filter) odds? [1 2 3 4 5])
((comp count filter) odd? [1 2 3 4 5])
(source comp)
(identity)
identity
(comp)
((comp) 4)
(comp 4)
(comp 4 5)
(4 5)
(use :reload 'testing)
(better-count-head-pairs [:h :h :h :t :h])
(use :reload 'testing)
(count-runs 2 #(= :h %) [:h :h :h :t :h])
(count-runs 2 #(= :h %) [:h :h :h :t :h :h])
(meta #'count-if)
(doc count-if)
(use :reload 'testing)
(doc count-if)
(doc meta0
)
(doc meta)
(doc with-meta)
(def a (with-meta a {:doc "Hello"}) 10)
(def (with-meta a {:doc "Hello"}) 10)
(def (with-meta a {:doc "Hello"}))
(def a (with-meta a {:doc "Hello"}))
(macroexpand '(def ^{:doc "Hello} a 10))
(macroexpand '(def ^{:doc "Hello"} a 10))
(doc a)
(macroexpand '(def ^Long a 10))
Long
String
Boolean
ISeq
clojure.lang.ISeq
(def a (with-meta 10 {:doc "A number"}))
(def a (with-meta '10 {:doc "A number"}))
(def a 10)
(def b (with-meta a {:doc "A number"}))
(def b (with-meta #'a {:doc "A number"}))
(doc def)
(with-meta 10 {:doc "A number"})
^{:doc "a number"} 10
^{:doc "a number"} [1 2 3]
(with-meta [1 2 3] {:doc "A number"})
(def a (with-meta [1 2 3] {:doc "A number"}))
(meta #'a)
(doc a)
(def c (with-meta [1 2 3] {:doc "A number"}))
(doc c)
(def ^{:doc "A number"} a 10)
(doc a)
(macroexpand '(^{:doc "A number} [1 2 3]))
(macroexpand '(^{:doc "A number"} [1 2 3]))
(doc def)
(doc partial)
(use :reload 'testing)
(better-count-head-pairs [:h :h :t :t])
(better-count-head-pairs [:h :h :h :t :t])
(use :reload 'testing)
(better-count-head-pairs [:h :h :h :t :t])
(meta #'better-count-head-pairs)
(doc partial)
(doc declare)
(macroexpand '(declare my-odd? my-even?))
(list 'odd)
(list (list 'odd))
(list (list (list 'odd)))
(defn deeply-nested [n]
(doc loop)
(defn deeply-nested [n]
(loop [n n result 'bottom]
(if (zero? n)
result
(recur (dec n) (list result)))))
(deeply-nested 1)
(deeply-nested 5)
(declare replace-symbol replace-symbol-expression)
(defn replace-symbol [coll oldsym newsym]
(if (empty? coll)
()
(cons (replace-symbol-expression
(first coll) oldsym newsym)
(replace-symbol
(rest coll) oldsym newsym))))
(defn replace-symbol-expression [symbol-expr oldsym newsym]
(if (symbol? symbol-expr)
(if (= symbol-expr oldsym)
newsym
symbol-expr)
(replace-symbol symbol-expr oldsym newsym)))
(replace-symbol (deeply-nested 5) 'bottom 'deepest)
(replace-symbol (deeply-nested 10000) 'bottom 'deepest)
(replace-symbol (deeply-nested 1000) 'bottom 'deepest)
(replace-symbol (deeply-nested 100) 'bottom 'deepest)
(doc lazy-seq)
(defn- coll-or-scalar [x & _] (if (coll? x) :collection :scalar))
(defmulti replace-symbol coll-or-scalar)
(defmethod replace-symbol :collection [coll oldsym newsym]
(lazy-seq
(when (seq coll)
(cons (replace-symbol (first coll) oldsym newsym)
(replace-symbol (rest coll) oldsym newsym)))))
(defmethod replace-symbol :scalar [obj oldsym newsym]
(if (= obj oldsym) newsym obj))
(replace-symbol (deeply-nested 10000) 'bottom 'deepest)
(replace-symbol (deeply-nested 1000) 'bottom 'deepest)
(replace-symbol (deeply-nested 100) 'bottom 'deepest)
(replace-symbol (deeply-nested 500) 'bottom 'deepest)
(replace-symbol (deeply-nested 700) 'bottom 'deepest)
(replace-symbol (deeply-nested 900) 'bottom 'deepest)
(replace-symbol (deeply-nested 800) 'bottom 'deepest)
(take 1 (replace-symbol (deeply-nested 800) 'bottom 'deepest))
(doc time)
(time 1)
(time (bad-fibo 100))
(time (bad-fibo 10))
(time (tail-fibo 1000))
(time (lazy-fibo 1000))
(time (lazy-fibo [] 1000))
(time (lazy-fibo))
(time (bad-fibo 10))
(time (tail-fibo 1000))
(time (nth (lazy-fibo) 1000))
(time (tail-fibo 1000))
(time (nth (lazy-fibo) 1000))
(time (tail-fibo 1000))
(time (nth (lazy-fibo) 1000))
(time (nth (lib-fibo) 1000))
(doc memoize)
(declare m f)
(defn m [n]
(if (zero? n)
0
(- n (f (m (dec n))))))
(defn f [n]
(if (zero? n)
1
(- n (m (f (dec n))))))
(time (m 250))
(time (m 100))
(def f (memoize f))
(def m (memoize m))
(source f)
(time (m 100))
(def m-seq (map m (iterate inc 1)))
(def f-seq (map f (iterate inc 1)))
(nth m-seq 10000)
(time (nth m-seq 10000))
(def f-seq (map f (iterate inc 0)))
(time (nth m-seq 10000))
(time (nth m-seq 10000000))
(time (nth m-seq 100000))
(time (nth m-seq 10000))
(doc ref)
(def a 10)
(deref a)
@a
a
(doc deref)
(def a (atom #{}))
@a
(def a (ref #{}))
@a
(def a (ref []))
@a
(def a (ref 10))
@a
(ref-set a 20)
(doc ref)
(doc ref-set)
(doc dosync)
(dosync (ref-set a 20)
)
@a
(def a 20)
@a
a
(def a (ref 10))
@a
(defrecord Message [sender text])
(Message. "Aaron" "Hello")
(->Message "Aaron" "Hello")
(Message. "Aaron" "Hello")
(def a (Message. "Aaron" "Hello"))
@a
a
(a :sender)
(:sender a)
(:text a)
(def messages (ref ()))
@messages
(defn bad-add-message [msg]
(dosync (ref-set messages (cons msg @messages))))
(bad-add-message (Messages. "Peter" "Hi"))
(bad-add-message (Message. "Peter" "Hi"))
@messages
(bad-add-message (Message. "Aaron" "Hello"))
@a
@messages
(doc cons)
(doc join)
(doc conj)
(doc alter)
(doc apply)
(defn add-message [msg]
(dosync (alter messages conj msg)))
(add-message (Message. "Tracy" "Toodles"))
@messages
(doc dosync)
(doc alter)
(def counter (ref -1))
(defn next-counter [] (dosync (commut counter inc)))
(defn next-counter [] (dosync (commute counter inc)))
(next-counter)
(defn next-counter [] (dosync (alter counter inc)))
(next-counter)
(doc map)
(doc ref)
(doc every?)
@messages
(defn validate-message-list [msgs] (every? #(and (:sender %) (:text %)) msgs))
(def a (ref () :validator validate-message-list))
(add-message "what")
(def messages (ref () :validator validate-message-list))
(add-message "what")
(add-message "John" "Cynical!")
(source add-message)
(add-message (Message. "John" "Cynical!"))
(def a (atom 10))
(doc reset!)
(doc ref-set)
(doc reset)
(source reset!)
(reset! "what")
(reset! a "what")
@a
(doc assoc)
(def a (atom [5 10]))
(swap! a assoc 0 2)
@a
(def counter (agent 0))
(send counter inc)
@counter
(send counter inc)
@counter
(send counter #(- % 2))
@counter
(send counter #(- % 2))
@counter
(reset! counter 0)
(send counter 0)
(send counter #(0))
(send counter #('0))
(send counter #('(0)))
(send counter #(identity 0))
(send counter inc)
counter
(send counter inc)
@counter
(class counter)
(send counter inc)
counter
inc
send
(def counter (agent 0))
(send counter 0)
(send counter 100)
@counter
(send counter #(identity 100))
(send counter inc)
(def counter (agent 0))
(send counter inc)
(send counter #(identity 100))
(doc send)
(apply #(identity 100) 10)
(apply #(identity 100) [10])
(apply #(identity 100 %) [10])
(apply (fn [] (identity 100)) [10])
(apply (fn [] (identity 100)) (10))
(apply (fn [] (identity 100)) '(10))
(apply (fn [x] (identity 100)) '(10))
(apply (fn [x] 100) '(10))
(send counter inc)
(def counter (agent 5))
(send counter inc)
@counter
(send counter (fn [&_] 100))
(send counter (fn [&_] 1000))
((fn [&_] 100))
100
(send counter 100)
@counter
(doc defn)
(complement)
(doc complement)
(source complement)
(doc doc)
(doc apply)
(apply + [1 2 3] [4 5 6])
(apply + [4 5 6])
(apply + 1 2 3 [4 5 6])
(doc not)
(doc zero)
(defn zero [x] (zero? x))
((not zero) 1)
((complement zero) 1)
((fn (not zero)) 1)
((fn [x] (not zero)) 1)
((fn [x] (not zero)) 0)
((fn [x] (not zero)) -1)
(not zero)
(zero)
(not zero)
zero
(boolean zero)
(not zero)
(doc complemetn)
(doc complement)
(source complement)
(defn not-zero [] (fn [x] (not (f x))))
(defn not-zero [] (fn [x] (not (zero x))))
((not-zero) 1)
((not-zero) 0)
((not-zero) -1)
(doc await)
(def counter (agent 0 :validator number?))
(send counter (fn [_] "boo"))
@counter
(agent-errors counter)
@counte
@counter
(clear-agent-errors counter)
(agent-errors counter)
(send counter (fn [_] 12321))
@counter
(await counter)
(doc dosync)
(macroexpand '(doc dosync))
(doc print-doc)
(doc source)
(macroexpand '(source filter))
(source source)
(source doc)
(source dosync)
(doc spit)
(doc slurp)
(doc clojure.java.io/reader)
(doc clojure.java.io/writer)
(doc commute)
(doc alter)
(doc ref-set)
(doc send-off)
(doc send)
(doc dosync)
(def a 10)
(binding [b a] b)
(let [b a] b)
(doc binding)
(doc let)
(defn slow-double [n] (sleep 100) (* n 2))
(defn slow-double [n] (Thread/sleep 100) (* n 2))
(defn call-slow-double [] (map slow-double [1 2 1 2 1 3]))
(time (doall (call-slow-double)))
(doc sleep)
(doc Thread/sleep)
(time (doall (call-slow-double)))
(time (doall (binding [slow-double (memoize slow-double)] call-slow-double)))
(defn ^:dynamic slow-double [n] (Thread/sleep 100) (* n 2))
(time (doall (binding [slow-double (memoize slow-double)] call-slow-double)))
(time (doall (binding [slow-double (memoize slow-double)] (call-slow-double))))
(doc memoize)
(defn demo-memoize []
(time
(dorun
(binding [slow-double (memoize slow-double)]
(calls-slow-double)))))
(defn calls-slow-double []
(map slow-double [1 2 1 2 1 2]))
(defn demo-memoize []
(time
(dorun
(binding [slow-double (memoize slow-double)]
(calls-slow-double)))))
(demo-memoize)
(time (dorun (binding [slow-double (memoize slow-double)] calls-slow-double)))
(time (dorun (binding [slow-double (memoize slow-double)] (calls-slow-double))))
(time (dorun (binding [slow-double (memoize slow-double)] (call-slow-double))))
(time (dorun (binding [slow-double (memoize slow-double)] (calls-slow-double))))
(defn call-slow-double [] (map slow-double [1 2 1 2 1 3]))
(time (dorun (binding [slow-double (memoize slow-double)] (call-slow-double))))
(doc set!)
