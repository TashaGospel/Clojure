counter
(send counter inc)
@counter
(class counter)
(send counter inc)
counter
inc
send
(def counter (agent 0))
(send counter 0)
(send counter 100)
@counter
(send counter #(identity 100))
(send counter inc)
(def counter (agent 0))
(send counter inc)
(send counter #(identity 100))
(doc send)
(apply #(identity 100) 10)
(apply #(identity 100) [10])
(apply #(identity 100 %) [10])
(apply (fn [] (identity 100)) [10])
(apply (fn [] (identity 100)) (10))
(apply (fn [] (identity 100)) '(10))
(apply (fn [x] (identity 100)) '(10))
(apply (fn [x] 100) '(10))
(send counter inc)
(def counter (agent 5))
(send counter inc)
@counter
(send counter (fn [&_] 100))
(send counter (fn [&_] 1000))
((fn [&_] 100))
100
(send counter 100)
@counter
(doc defn)
(complement)
(doc complement)
(source complement)
(doc doc)
(doc apply)
(apply + [1 2 3] [4 5 6])
(apply + [4 5 6])
(apply + 1 2 3 [4 5 6])
(doc not)
(doc zero)
(defn zero [x] (zero? x))
((not zero) 1)
((complement zero) 1)
((fn (not zero)) 1)
((fn [x] (not zero)) 1)
((fn [x] (not zero)) 0)
((fn [x] (not zero)) -1)
(not zero)
(zero)
(not zero)
zero
(boolean zero)
(not zero)
(doc complemetn)
(doc complement)
(source complement)
(defn not-zero [] (fn [x] (not (f x))))
(defn not-zero [] (fn [x] (not (zero x))))
((not-zero) 1)
((not-zero) 0)
((not-zero) -1)
(doc await)
(def counter (agent 0 :validator number?))
(send counter (fn [_] "boo"))
@counter
(agent-errors counter)
@counte
@counter
(clear-agent-errors counter)
(agent-errors counter)
(send counter (fn [_] 12321))
@counter
(await counter)
(doc dosync)
(macroexpand '(doc dosync))
(doc print-doc)
(doc source)
(macroexpand '(source filter))
(source source)
(source doc)
(source dosync)
(doc spit)
(doc slurp)
(doc clojure.java.io/reader)
(doc clojure.java.io/writer)
(doc commute)
(doc alter)
(doc ref-set)
(doc send-off)
(doc send)
(doc dosync)
(def a 10)
(binding [b a] b)
(let [b a] b)
(doc binding)
(doc let)
(defn slow-double [n] (sleep 100) (* n 2))
(defn slow-double [n] (Thread/sleep 100) (* n 2))
(defn call-slow-double [] (map slow-double [1 2 1 2 1 3]))
(time (doall (call-slow-double)))
(doc sleep)
(doc Thread/sleep)
(time (doall (call-slow-double)))
(time (doall (binding [slow-double (memoize slow-double)] call-slow-double)))
(defn ^:dynamic slow-double [n] (Thread/sleep 100) (* n 2))
(time (doall (binding [slow-double (memoize slow-double)] call-slow-double)))
(time (doall (binding [slow-double (memoize slow-double)] (call-slow-double))))
(doc memoize)
(defn demo-memoize []
(time
(dorun
(binding [slow-double (memoize slow-double)]
(calls-slow-double)))))
(defn calls-slow-double []
(map slow-double [1 2 1 2 1 2]))
(defn demo-memoize []
(time
(dorun
(binding [slow-double (memoize slow-double)]
(calls-slow-double)))))
(demo-memoize)
(time (dorun (binding [slow-double (memoize slow-double)] calls-slow-double)))
(time (dorun (binding [slow-double (memoize slow-double)] (calls-slow-double))))
(time (dorun (binding [slow-double (memoize slow-double)] (call-slow-double))))
(time (dorun (binding [slow-double (memoize slow-double)] (calls-slow-double))))
(defn call-slow-double [] (map slow-double [1 2 1 2 1 3]))
(time (dorun (binding [slow-double (memoize slow-double)] (call-slow-double))))
(doc set!)
(source str)
(doc set!)
(doc set)
(doc send)
(use :reload 'testing)
(Message. "John" "hi")
(load-file "/src/testing.clj")
(pwd)
(load-file "src/testing.clj")
(Message. "John" "hi")
messages
backup-agent
(load-file "src/testing.clj")
(defrecord Message [sender text])
(Message. "John" "hi")
(->Message "John" "hi")
(testing.Message. "John" "hi")
(use :reload 'testing)
messages
(use :reload 'testing)
messages
backup-agent
Message.
user.Message.
testing.Message.
(testing.Message. "John" "Green")
(Message. "John" "Green")
(import 'testing)
(import '[testing Message])
(Message. "John" "Green")
(ns myapp)
(ns user)
(add-message-with-backup (Message. "Peter" "Hello there"))
@messages
(add-message-with-backup (Message. "Fluffy" "Howdy!"))
(#testing.Message{:sender "Fluffy", :text "Howdy!"} #testing.Message{:sender "Peter", :text "Hello there"})
(use 'examples.snake)
(game)
(doc def)
(def a {left 1 right 0})
(def a {'left 1 'right 0})
('left a)
(a 'left)
(doc vec)
(doc map)
(doc apply)
(apply + [1 2 3])
(defn thing [%p] (class p))
(defn thing [&p] (class p))
(defn thing [x &p] (class p))
(defn thing [x &p] (class))
(thing 1)
(thing 1 2)
(class 1)
(defn thing [x &p] (class x))
(thing 1 2)
(defn thing [x & p] (class p))
(thing 1 2)
(thing 1 [2])
(thing 1 [2 2 3])
(thing 1 [2 2 3] 12 1)
(doc when)
(doc keep-indexed)
(when zero? 0 1)
(when (zero? 0) 1)
(when (zero? 0) 2)
(when zero? 0 2)
(macroexpand '(when zero? 0 2))
(zero?)
(when zero? 0 2)
(macroexpand '(when zero? 0 2))
(if zero? (do 0 2))
(if zero? (do 2 4))
(if zero? true0
)
(if zero? 1)
(if zero? 0)
(if zero? 65)
(if zero?)
(if zero? 0)
(zero?)
zero?
(if #{\t} 1 2)
#{\t}
#{}
(when #{} 1)
(when #{} 1 2)
(doc keep-indexed)
(doc for)
(macroexpand '(take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)] [x y])))
(take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)] [x y]))
(doc doseq)
([1 2] 0)
([1 2] 1)
([1 2] 3)
([1 2] 0)
(time ([1 2] 0))
(time (nth [1 2] 0))
(time ([1 2] 0))
(time (nth [1 2] 0))
(doc concat)
(doc conj)
(use :reload 'reader.snake)
(point-to-screen-rect [5 10])
(use :reload 'reader.snake)
(point-to-screen-rect [5 10])
(doc vec)
(point-to-screen-rect [5 10])
(use :reload 'reader.snake)
(point-to-screen-rect [5 10])
(doc conj)
(use :reload 'reader.snake)
(point-to-screen-rect [5 10])
(use :reload 'reader.snake)
(point-to-screen-rect [5 10])
(vec ([50 100]))
(vec '([50 100]))
(map #(* % point-size) [5 10])
(vec (map #(* % point-size) [5 10]))
(list (vec (map #(* % point-size) [5 10])))
(class (map #(* % point-size) [5 10]))
(use :reload 'testing)
(use :reload 'reader.snake)
(point-to-screen-rect [5 10])
(doc rand-int)
(list [1 1])
'([1 1])
(class '([1 1]))
(class (list [1 1]))
(macroexpand '(list [1 1]))
(macroexpand '([1 1]))
(macroexpand '('([1 1])))
(quote ([1 1]))
(class (quote ([1 1])))
(doc butlast)
(use :reload 'reader.snake)
(move (create-snake))
(move (create-snake) :grow)
(move (create-snake) 1)
(move (create-snake) 123124)
(move (create-snake) :true)
(move (create-snake) :false)
(move (create-snake) false)
(move (create-snake) nil)
(move (create-snake))
(move (create-snake) nil)
((nil))
(boolean (nil))
(boolean '(nil))
(boolean (first '(nil)))
(boolean (first '(1)))
(boolean (first '(false)))
(doc contains?)
(use :reload 'reader.snake)
(head-overlaps-body? {:body ([1 1] [1 2] [1 3] [1 1])})
(head-overlaps-body? {:body '([1 1] [1 2] [1 3] [1 1])})
(doc contains?)
(contains? '([1 1] [1 2]) [1 1])
(contains? [[1 1] [1 2]] [1 1])
(contains? (set '([1 1] [1 2])) [1 1])
(set '([1 1] [1 2]))
(use :reload 'reader.snake)
(head-overlaps-body? {:body '([1 1] [1 2] [1 3] [1 1])})
(head-overlaps-body? {:body '([1 2] [1 3] [1 1] [1 1])})
(head-overlaps-body? {:body '([1 2] [1 3] [1 1] [1 1] [1 2])})
(contains? [12 34 56] 12)
(contains? [12 34 56] 0)
(contains? [12 34 56] 1)
(contains? '(12 34 56) 1)
(contains? '(12 34 56) 12)
(contains? '(12 34 56) 0)
(contains? '(12 34 56) 12)
(contains? #{12 34 56} 12)
(contains? #{12 34 56} 1421)
(use :reload 'reader.snake)
(lose? {:body [[1 1] [1 2] [1 3]]})
(lose? {:body [[1 1] [1 2] [1 1]]})
(lose? {:body '([1 1] [1 2] [1 1])})
(lose? {:body '([1 1] [1 2] [1 3])})
(use :reload 'reader.snake)
(eats? {:body [[1 1] [1 2]]} {:location [2 2]})
(use :reload 'reader.snake)
(eats? {:body [[1 1] [1 2]]} {:location [2 2]})
(eats? {:body [[2 2] [1 2]]} {:location [2 2]})
(turn (create-snake) [0 -1])
(use :reload 'reader.snake)
(turn (create-snake) [0 -1])
(turn (create-snake) VK_UP)
(turn (create-snake) (VK_UP dir))
(turn (create-snake) (dir VK_UP))
(turn (create-snake) (dirs VK_UP))
(ref-set jk 10)
(doc ref-set)
(use :reload 'reader.snake)
(def test-snake (ref nil))
(def test-apple (ref nil))
(reset-game snake apple)
(reset-game test-snake test-apple)
@test-snake
@test-apple
(reset-game test-snake test-apple)
@test-apple
(use :reload 'reader.snake)
(update-direction test-snake [0 -1])
(update-direction test-snake [2 3])
(update-direction test-snake [1 0])
(use :reload 'reader.snake)
@test-snake
@test-apple
(update-positions test-snake test-apple)
@test-apple
(update-positions test-snake test-apple)
@test-apple
(eats? {:body [[1 1] [1 2]]} {:location [2 2]})
(use :reload 'reader.snake)
(update-positions test-snake test-apple)
(reset-game test-snake test-apple)
(dosync (alter test-apple assoc :location [1 1])
)
@test-apple
@test-snake
(require '[examples.snake :as ga])
(ga/game)
(update-positions test-snake test-apple)
@test-snake
@test-apple
(. Math PI)
(import '(java.lang.Math PI))
(.toString 123)
(.toUpper 123)
(.toUpper "123")
(.toUppercase "123")
(.toUpperCase "123")
(.toUpperCase "asdfsadf")
(doc doseq)
(doc doall)
(doc proxy)
(doc doto)
(let [a 10])
(let [a 10] a)
(let [a 10] (inc a))
(let [a 10])
(use :reload 'reader.snake)
(game)
(doc every?)
(doc merge)
StringBuilder.
(import '(java.io FileInputStream InputStreamReader BufferedReader))
StringBuilder.
(StringBuilder.)
(doc with)
(doc with-open)
(-> src
FileInputStream.
InputStreamReader.
BufferedReader.)
(-> "this.clj"
FileInputStream.
InputStreamReader.
BufferedReader.)
(doc ->)
(defrecord Book [title author])
(->Book "TFIOS" "John Green")
(macroexpand '(->Book "TFIOS" "John Green"))
(macroexpand '(Book. "TFIOS" "John Green"))
(macroexpand '(-> Book "TFIOS" "John Green"))
(-> Book "TFIOS" "John Green")
(macroexpand '(-> src
FileInputStream.
InputStreamReader.
BufferedReader.))
(doc neg?)
(java-doc .read)
(java-doc "read")
(javadoc "read")
(int \A)
(int "A")
(int \a)
(char 65)
(char 13)
(char 1)
(char 14)
(char 15)
(char 16)
(int \n)
(int \\n)
(int \newline)
(char 10)
(int \space)
(negs? \eof)
(int \eof)
(int \0)
(doc eval)
(read)
(class (read))
(eval (read))
(.read)
(use :reload 'testing)
(gulp "output/messages-backup.clj")
(use :reload 'testing)
(File. ".")
(use :reload 'testing)
(expectorate "output/whoa.txt" "I am useless!")
(use :reload 'testing)
(gulp "output/messages-backup.clj")
(use :reload 'testing)
(gulp "output/messages-backup.clj")
(doc cond)
(macroexpand '(cond true 1 nil 2))
(doc conp)
(doc condp)
(doc type)
(use :reload 'testing)
(gulp "output/messages-backup.clj")
(definterface IOFactory (^java.io.BufferedReader make-reader [this])
(^java.io.BufferedWrite make-writer [this]))
(doc extend)
(doc extend-type)
(use :reload 'testing)
(make-writer "output/messages-backup.clj")
(make-writer (File. "output/messages-backup.clj"))
(make-writer (java.io.File. "output/messages-backup.clj"))
(make-reader (java.io.File. "output/messages-backup.clj"))
(make-reader (java.io.FileInputStream. "output/messages-backup.clj"))
(make-reader (java.io.FileOutputStream. "output/messages-backup.clj"))
(make-reader (java.io.InputStreamReader. "output/messages-backup.clj"))
(doc extend-type)
(extend-protocol)
(doc extend-protocol)
(use :reload 'testing)
(doc make-writer)
(deftype CryptoVault [filename keystore password])
(def vault (CryptoVault. "vault-file" "keystore" "toomanysecrets"))
(.filename vault)
(:filename vault)
("filename" vault)
(vault :filename)
(filename vault)
(.filename vault)
(. filename vault)
(doc .)
(.filename CryptoVault)
(.filename vault)
(.filename CryptoVault)
(macroexpand '(.filename vault))
(. vault filename)
(. CryptoVault filename)
(. vault filename)
(use '(clojure [string :only (split)]))
(use '(clojure [string :only [split]]))
(.PI Math)
(. Math PI)
(.PI Math)
(doc key)
(source key)
(key {:a 10})
(map key {:a 10})
(doc keys)
(map key {:a 10 :b 20})
(keys {:a 10 :b 20})
(key :a)
(key {:a})
(key :a 10)
(key '(:a 10))
(key [:a 10])
