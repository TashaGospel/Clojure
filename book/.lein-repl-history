(my-println "what")
(use :reload 'testing)
(my-println "what")
(use :reload 'testing)
(my-println "what")
(my-println nil)
(use :reload 'testing)
(my-println nil)
(use :reload 'testing)
(my-println 42)
(use :reload 'testing)
(my-println 42)
(isa? Double Number)
(isa? Double String)
(source isa?)
(not 1)
(not nil)
(not nbil)
(not `nbil)
(class `nbil)
(class 'nbil)
(class '(nbil))
(class `(nbil))
(class `(1))
(class `(1 2))
(use :reload 'testing)
(my-print (java.sql.Date 0))
(my-println (java.sql.Date. 0))
(my-println (java.sql.Date. 10))
(my-println (java.sql.Date. 1000))
(my-println (java.sql.Date. 100000))
(my-println (java.sql.Date. 10000000))
(my-println (java.sql.Date. 1000000000))
(my-println (java.sql.Date. 1000000000000000000000000))
(my-println (java.sql.Date. 1000000000000000000000000N))
(my-println (java.sql.Date. 1000000000000000))
(my-println (java.sql.Date. 10000000000000))
(my-println (java.sql.Date. 1000000000000))
(my-println (java.util.Random.))
(doc demulti)
(doc defmulti)
(doc defmethod)
(use :reload 'testing)
(isa? 1 Number)
(isa? 1 Integer)
(doc isa?)
(my-print '(1 2 3))
(my-println '(1 2 3))
(my-println [1 2 3])
(use :reload 'testing)
(my-println [1 2 3])
(use :reload 'testing)
(my-println [1 2 3])
(my-println #{1 2 3})
(class [1 2 3])
(doc prefer-method)
(use :reload' testing)
(use :reload 'testing)
(my-print '(1 2))
(my-println '(1 2))
(my-println [1 2])
(doc prefer-method)
(use :reload 'testing)
(source my-print)
(source prefer-method)
(my-println [1 2])
(use :reload 'testing)
(my-println [1 2])
(my-println '(1 2))
:Checking
::Checking
(use :reload 'account)
(struct account 1 ::account/Savings 100M)
(struct account 1 :account/Savings 100M)
(alias 'acc 'account
)
(def test-savings (struct account 1 ::acc/Savings 100M))
(struct account 1 :Savings 100M)
(struct account 1 ::Savings 100M)
(struct account 1 :acc/Savings 100M)
(struct account 1 ::acc/Savings 100M)
(doc ::)
(def test-checking (struct account ::acc/Checking 250M))
(use :reload 'account)
(interest-rate test-savings)
(interest-rate test-checking)
test-checking
(def test-checking (struct 2 account ::acc/Checking 250M))
(def test-checking (struct account 2 ::acc/Checking 250M))
(interest-rate test-checking)
test-savings
test-checking
(use :reload 'account)
(interest-rate test-checking)
(use :reload 'account)
(thing)
(use :reload 'account)
(thing)
(use :reload 'account)
(account-level test-savings)
(account-level {:tag ::acc/Checking :balance 10000M})
(account-level {:tag ::acc/Checking :balance 5000M})
(account-level {:tag ::acc/Checking :balance 4999M})
(doc ->)
(macroexpand '(-> (make-hie) (derive :foo :bar)))
(doc make-hierarchy)
(doc derive)
(defmulti add class)
(defmethod add Integer [a b] (+ a b))
(defmethod add Float [a b] (+ a b))
(add 1 2)
(use :reload 'account)
(service-charge test-checking)
(service-charge {:tag ::acc/Savings :balance 1000})
(doc in-ns)
(doc ns)
(source in-ns)
(doc in-ns)
(souce in-ns)
(source in-ns)
(source ns)
(use :reload 'account)
(service-charge test-checking)
(service-charge {:tag ::acc/Checking :balance 10000})
(service-charge {:tag ::acc/Checking :balance 1000})
(service-charge {:tag ::acc/Savings :balance 1000})
::acc/Savings
(use :reload 'account)
::acc/Checking
acc
::account/Checking
(alias 'acc 'account)
:acc/Checking
::acc/Checking
(doc alias)
(isa? ::acc/Checking ::acc/Account)
(isa? ::acc/Checking ::acc/Accounta)
(isa? :acc/Checking ::acc/Account)
(class 
'[1 2 3])
(class '[1 2 3])
(class [1 2 3])
(class [1])
(class '[1])
(class '[clojure.inspector :only (inspect-tree)))
(class '[clojure.inspector :only (inspect-tree)])
(inspect-tree {:clojure {:creator "Rich" :runs-on-jvm true}})
(class '[clojure.inspector :only (inspect-tree)])
(use '[clojure.inspector :only (inspect-tree)])
(inspect-tree {:clojure {:creator "Rich" :runs-on-jvm true}})
(inspect-tree (System/getProperties))
(inspect-tree {:clojure {:creator "Rich" :runs-on-jvm true}})
(defmulti add class)
(defmethod add Number [a b] (+ a b))
(add 2 3)
(doc assert)
(assert nil)
(doc is)
(use :reload '[clojure.test :only (is)])
(doc is)
(is true "Yep")
(is nil "Yep")
(is (string? 10))
(is (string? 10) "10 isn't string")
(is (string? "hi") "10 isn't string")
(source is)
(source assert)
(doc is)
(doc instance?)
(is (instance? java.util.Collection "foo"))
(is (instance? java.util.Collection [1 2]))
(is (instance? java.util.Collection {:a 1}))
(is (instance? java.util.Collection #{1 2}))
(is (instance? java.util.Collection '(1 2 3)))
(doc defmethod)
(source class)
(class nil)
(class null)
null
nil
true
tru
(source with-open)
('(1 2 3) 0)
([1 2 3] 0)
('a {a 10 b 20})
('a {'a 10 'b 20})
( {'a 10 'b 20} 'a)
(keyword aasd)
(keyword 'aasd)
('(1 2 3) 0)
(get '(1 2 3) 0)
(get '(1 2 3) 1)
(doc get)
(get [1 2 3] 1)
(#{ 1 2 3} 1)
(#{ 1 2 3} 42)
(#{ 1 2 3} 3)
({ 1 2 3 4} 1)
({ 1 2 3 4} 3)
({ 1 2 3 4} 4)
(doc close)
(doc with-open)
(macroexpand '(with-open [rdr Reader] (.write rdr)))
(doc finally)
(macroexpand '(.pow Math))
(.pow Math 2 10)
(. Math pow 2 10)
(macroexpand '(. Math pow 2 10))
(macroexpand '(with-open [rdr Reader] (.write rdr) (.hasdf)))
(macroexpand '(with-open [rdr Reader wr Writer] (.write rdr) (.hasdf)))
(source spit)
(source with-open)
(source spit)
(doc find)
(find {:a 10 :b 20} :a)
(find {:a 10 :b 20} 19)
(find {:a 10 :b 20} 10)
(find {:a 10 :b 20} :a)
({:a 10 :b 20} :a)
(Exception. "oops")
(throw (Exception. "oops")_
)
(throw (Exception. "oops"))
(try
(throw (Exception. "something failed"))
(finally
(println "we get to clean up")))
(macroexpand '(Math/pow))
(doc /)
(macroexpand '(Math/pow 1 2))
(use 'testing)
(class-available? "borg.util.Assimilate")
(use :reload 'testing)
(class-available? "borg.util.Assimilate")
(use :reload 'testing)
(class-available? "borg.util.Assimilate")
(CLass/forName "java.lang.String")
(Class/forName "java.lang.String")
(Class/forName "java.lang.Strin")
(Class/forName "java.lang.Number")
(Class/forName "clojure.lang.FLoat")
(Class/forName "clojure.lang.Float")
(class 1.0)
(Class/forName "java.lang.Float")
(doc reify)
(doc str)
(uncheck-add 10000000000000000000000000000N 1)
(unchecked-add 10000000000000000000000000000N 1)
(unchecked-add 10000000000000000000000000000N 999999999999999999999999999999999999999999999999999999999)
(unchecked-add 10000000000000000000000000000N 99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999)
(unchecked-add 10000000000000000000000000000N 99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999N)
(+ 10000000000000000000000000000N 99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999N)
(unchecked-add 9223372036854775807 1)
(+ 9223372036854775807 1)
(+' 9223372036854775807 1)
(time (unchecked-add 9223372036854775807 1))
(time (+ 9223372036854775807 1))
(time (+' 9223372036854775807 1))
(time (+ 9223372036854775806 1))
(time (unchecked-add 9223372036854775806 1))
(time (+' 9223372036854775806 1))
(+' 1 2)
(time (+' 1 2))
(time (+ 1 2))
(time (unchecked-add 1 2))
(doc +')
(doc +)
(doc unchecked-add)
(doc deftype)
(deftype Book [title author])
(Book. "TFIOS" "John Green")
(. (Book. "TFIOS" "John Green") title)
(.title (Book. "TFIOS" "John Green"))
((Book. "TFIOS" "John Green")/title)
(. (Book. "TFIOS" "John Green") title)
Book.
(. (->Book "TFIOS" "John Green") title)
(doc time)
(doc dotimes)
(source dotimes)
(def a 10)
(let [a 20] a)
(macroexpand '(dotimes [_ 5] (inc 1)))
(use :reload 'testing)
(sum-to 10)
(sum -1)
(sum-to -1)
(sum-to 1)
(sum-to 2)
(sum-to 3)
(sum-to 100000N)
(sum-to 1000000000000000000N)
(sum-to 1000000000N)
(sum-to 10000000N)
(use :reload 'testing)
(sum-to 10000000N)
(dotimes [_ 5] (sum-to 100N))
(dotimes [_ 5] (time (sum-to 100N)))
(dotimes [_ 5] (time (sum-to 100)))
(use :reload 'testing)
(dotimes [_ 5] (time (sum-to 100)))
long
Long
(doc long)
(use :reload 'testing)
(dotimes [_ 5] (time (sum-to 100)))
(use :reload 'testing)
(dotimes [_ 5] (time (sum-to 100)))
(use :reload 'testing)
(dotimes [_ 5] (time (sum-to 100)))
(use :reload 'testing)
(dotimes [_ 5] (time (sum-to 100)))
(dotimes [_ 5] (time (sum-to 10000)))
(use :reload 'testing)
(dotimes [_ 5] (time (sum-to 10000)))
(use :reload 'testing)
(dotimes [_ 5] (time (sum-to 10000)))
(dotimes [_ 5] (time (sum-to 100000000)))
(sum-to 10000000000000000000)
(sum-to 10000000000)
(doc reduce)
(reduct + (range 1 11))
(reduce + (range 1 11))
(reduce + (range 1 2))
(reduce + (range 1 1))
(reduce + (range 1 10000))
(time (reduce + (range 1 10000))
)
(time (reduce + (range 1 10000)))
Class
(defn describe-class [c] {:name (.getName c) :final (java.lang.reflect.Modifier/isFinal (.getModifiers c))})
(describe-class 1)
(describe-class String)
(defn describe-class [^class c] {:name (.getName c) :final (java.lang.reflect.Modifier/isFinal (.getModifiers c))})
(defn describe-class [^Class c] {:name (.getName c) :final (java.lang.reflect.Modifier/isFinal (.getModifiers c))})
(describe-class 1)
(defn describe-class [^{:tag Class} c] {:name (.getName c) :final (java.lang.reflect.Modifier/isFinal (.getModifiers c))})
(describe-class 1)
(describe-class String)
(describe-class Number)
(describe-class Float)
(describe-class Object)
(describe-class Class)
(describe-class Exception)
(describe-class IllegalArgumentException)
(describe-class IOException)
(describe-class 'IOException)
(use :reload 'sax)
(doc proxy)
(macroexpand '(.. SAXParserFactory newInstance newSAXParser))
(. Math PI)
Math/PI
(Math/PI)
(macroexpand '(.. SAXParserFactory newInstance newSAXParser
(parse (InputSource. (StringReader. source)) handler)))
(use :reload 'sax)
(demo-sax-parse "<foo>
<bar>Body of bar</bar>
</foo>" print-element-handler)
Thread
(.start (Thread.
(proxy [Runnable] [] (run [] (println "I ran!")))))
(.start (Thread.
(proxy [Runnable] [] (runa [] (println "I ran!")))))
#(println "foo")
(#(println "foo"))
(dotimes [i 5]
(.start
(Thread.
(fn []
(Thread/sleep (rand 500))
(println (format "Finished %d on %s" i (Thread/currentThread)))))))
(Thread/sleep 100)
(Thread/sleep 1000)
(doc make-array)
(make-array Integer 5 5)
(make-array Integer/TYPE 5 5)
Integer/Type
Integer/TYPE
Float/TYPE
Double/TYPE
BigInt/TYPE
BigDecimal/TYPE
String/TYPE
Integer
(make-array Integer 5 5)
(make-array int 5 5)
(make-array 'int 5 5)
(doc int)
(int 1)
(make-array Integer 5 5)
(make-array Integer 5 5 5 5 5)
(seq (make-array Integer 5 5))
(seq (make-array String 5 5))
(seq (make-array String 5))
(seq (make-array String 5 5))
(seq (seq (make-array String 5 5)))
(seq (seq (seq (make-array String 5 5))))
(map seq (seq (make-array String 5 5)))
(map seq (map seq (seq (make-array String 5 5 5))))
(map map seq (seq (make-array String 5 5 5))))
(map seq (map seq (seq (make-array String 5 5 5))))
(map seq (map seq (map seq (seq (make-array String 5 5 5)))))
(map seq (map seq (seq (make-array String 5 5 5))))
(map seq (seq (make-array String 5 5 5)))
(seq (make-array String 5))
(seq (make-array String 2))
(map seq (seq (make-array String 2 2)))
(map seq (seq (make-array String 2 2 2)))
(map map seq (seq (make-array String 2 2 2)))
(def map-seq (partial map seq))
(map map-seq (seq (make-array String 2 2 2)))
(map map-seq (seq (make-array String 2 2 2 2)))
(def map-map-seq (partial map map-seq))
(map map-map-seq (seq (make-array String 2 2 2 2)))
(map (partial map (partial map seq)) (seq (make-array String 2 2 2 2)))
(doc partial)
(alength (make-array 2 2 2 2))
(alength (make-array Strin 2 2 2 2))
(alength (make-array String 2 2 2 2))
(String/format)
(String/format "%d" 2)
(String/format "%d" (to-array [2]))
(doc aget)
(doc amap)
(doc areduce)
(macroexpand '(amap strings idx _ (.toUpperCase (aget strings idx))))
(source amap)
(:require '[clojure.string :as str])
(macroexpand '(str/split))
(macroexpand '(str/split 1 2))
(str/join "a b c d w
"
(str/join "a b c d w" #"s+")
(require '[clojure.string :as str])
(str/join "a b c d w" #"s+")
(doc str/join)
(str/split "a b c d w" #"s+")
(str/split "a b c d w" #"\s+")
(macroexpand '(str/split "a b c d w" #"\s+"))
(. str split
)
(defn thing [a b & {:keys [title author]}] (str a b title author))
(thing 1 2 :title "TFIOS" :author "John")
(thing 1 2 {:title "TFIOS" :author "John"})
(defn thing [a b & {title :title author :author}] (str a b title author))
(thing 1 2 {:title "TFIOS" :author "John"})
(thing 1 2 :title "TFIOS" :author "John")
(defn thing [a b {title :title author :author}] (str a b title author))
(thing 1 2 {:title "TFIOS" :author "John"})
(thing 1 2 :title "TFIOS" :author "John")
(doc start)
(doc clojure.string/split)
(clojure.string/split)
(doc clojure.java.io/reader)
(doc clojure.java.io/resource)
(doc clojure.string/split)
(doc clojure.string/join)
(doc doc)
(source doc)
(doc source)
(source source)
(.. System out println "Hello")
(.. System out (println "Hello"))
(doc read)
(println (read))
(+ (read) (read))
(+ (read))
(+ (int (read)) (int (read)))
(source read)
(doc partial)
(source partial)
(use :reload 'testing)
(drill str 3 [[[1 2 3]]])
((drill str 3) [[[1 2 3]]])
(use :reload 'testing)
((drill str 3) [[[1 2 3]]])
((drill max 3) [[[1 2 3]]])
((partial map (partial map str)) [[1 2 3]])
((drill str 4) [[[1 2 3]]])
((drill str 2) [[[1 2 3]]])
((drill str 3) [[[1 2 3]]])
(str 1 2 3)
((partial map (map str)) [[1 2 3]])
((partial map (partial map str)) [[1 2 3]])
(str [1 2 3])
(map str [1 2 3])
(use :reload 'testing)
((drill str 3) [[[1 2 3]]])
((drill str 4) [[[1 2 3]]])
((drill str 2) [[[1 2 3]]])
((drill max 3) [[[1 2 3]]])
((drill + 3) [[[1 2 3]]])
((drill + 2) [[[1 2 3]]])
((drill + 3) [[[1 2 3]]])
(doc computation)
(multiply-by-3 4)
(ns testing)
(multiply-by-3 10)
