exit
(require 'examples.introduction)
(fibs 5)
(fib 5)
(require 'examples.introduction)
(println (seq (.getURLs (java.lang.ClassLoader/getSystemClassLoader))))
(require 'examples.introduction)
(take 10 examples.introduction/fibs)
(take 2)
(doc take)
(fibs)
(examples.introduction/fibs)
(println examples.introduction/fibs)
(println examples.introdtake 10 examples.introduction/fibs)
(take 10 examples.introduction/fibs)
(refer 'examples.introduction)
(use 'examples.introduction)
(doc take)
(take 10 fibs)
(use:reload 'examples.introduction)
(use :reload 'examples.introduction)
(doc str)
(doc fibs)
(use 'testing')
(load-file "testing.clj")
(hellon "me")
(doc hellon)
(doc str)
(find-doc nil?)
(find-doc st)
(find-doc "reduce")
(clojure.repl/source identity)
(refer 'clojure.repl)
(source identity)
(source hellon)
42
[1, 2, 3]
(println (str "what", "is", "this?
"))
[1 2]
(concat [1 2])
(- 10 5 2)
(<= 5 10)
(> 5 10)
(/ 7 21)
(/ 21 7)
(class 5)
(class 1)
(class +)
(class (+))
(class 21/5)
(/ 22.0 7)
(pi)
4
pi
(quot 22 7)
(rem 22 8)
(/ 0.00000001 1000000000000)
(/ 0.00000001M 1000000000000)
(+ 1 (/ 0.00000001M 1000000000000))
(+ 1 (/ 0.00000001 1000000000000))
(+ 1 (/ 0.00000001N 1000000000000))
(* 1000 1000 1000 1000 1000 1000 1000)
(* 1000 1000 1000 1000 1000 1000 1000N)
'what'
'what
"what
"
"This is
a
multiline
string
"
"what"
(println "This
is
Sparta")
(println 'this is not sparta)
(println 'this is not sparta')
(println 'what)
(println 'what is not sparta')
(println 'what)
(.toUpperCase "what")
(.toUpperCase 'what)
(.toUpperCase "WQ")
(str 1)
(str 1 nil 2)
(str \n)
(str \newline)
(str \\n)
(print \y)
(println \y)
(println \n)
(println \newline)
(println "\n")
(println "n")
(Character/toUpperCase \s)
(interleave "What is This" "We don't Know")
(str (interleave "What is This" "We don't Know"))
(apply (str (interleave "What is This" "We don't Know")))
(apply str (interleave "What is This" "We don't Know"))
(doc apply)
(take-nth 2 "WWhea td oins' tT hKinso")
(apply str (take-nth 2 "WWhea td oins' tT hKinso"))
(apply str (t"WWhea td oins' tT hKinso"))
(apply str ("WWhea td oins' tT hKinso"))
(apply str "WWhea td oins' tT hKinso")
(apply str (interleave "What do you want" "Hello There")))
(apply str (interleave "What do you want" "Hello There"))
(interleave "What do you want" "Hello There")
(nil? ())
(zero? 0)
(zero? 1)
(empty? ())
(empty? (1))
(empty? [1])
(empty? (1, 2, 3))
(empty? [])
(if [] "What" "ookay")
(if [] "True" "false"))
(if [] "True" "false")
(if false "True" "false")
(if nil "True" "false")
(if 0 "True" "false")
(true? 1)
(true? true)
(nil? [])
(nil? nil)
(def inventors {"Lisp" "McCarthy", "Clojure" "Hickey"})
(inventors "Lisp")
(inventors "McCarthy")
(deref inventors)
@inventors
(def visitors (atom #{"things" "woah"}))
(deref atom)
(deref visitors)
(get inventors "McCarthy" "I don't know")
(get inventors "Clojure" "I don't know")
(def inventors {:Lisp "McCarthy", :Clojure "Hickey"})
(:Lisp inventors)
(inventors :lisp)
(inventors :Lisp)
(doc defrecord)
(defrecord Book [title author])
user.Book.
user.Book
(-> Book "title" "author)
")
(->Book "title" "author")
book
inventors
(inventors
)
inventors
(inventors "Clojure")
(inventors :Clojure)
(defrecord Book ["title" "author"])
(defrecord Book [title author])
(def b (->Book "TFIOS" "John Green"))
b
(:author b)
(b :title)
(Book title)
(->Book "TFIOS" "John Green")
(def a (->Book "TFIOS" "John Green"))
(a :title)
(:title a)
(def a (Book. "TFIOS" "John Green"))
a
(:title a)
(a :title)
(1 2)
'(1 2)
(quote (1 2))
; this is kinda cool
(doc quote?)
(quotes? 'hello)
(symbol? 'hello)
(symbol? "hello")
(symbol? (quote "hello"))
(symbol? 'hello)
(symbol? '(hello))
(load-file 'testing.clj)
(load-file "testing.clj")
(hellon)
(hellon "me")
(load-file "testing.clj")
(hellon)
(hellon "me")
(doc split)
(use 'clojure.string)
(doc split)
(filter #(> (count %) 2) (str/split "A fine day it is" #"\W+"))
(filter #(> (count %) 2) (split "A fine day it is" #"\W+"))
(filter #(> (count %) 2) (split "A fine day it is"))
(filter #(> (count %) 2) (split "A fine day it is" #"\W+"))
(defn indexable-words [text]
(let [indexable-word? (fn [w] (> (count w) 2))]
(filter indexable-word? (str/split text #"\W+"))))
(filter indexable-word? (split text #"\W+"))))
(defn indexable-words [text]
(let [indexable-word? (fn [w] (> (count w) 2))]
(filter indexable-word? (split text #"\W+"))))
(indexable-words "What do you want?")
(println "what" println "okay)
")
(println "what" println "okay")
(println "what" (println "okay"))
(doc let)
(load-file "testing.clj")
(str "hi" "what")
(defn make-greeter [greeting-prefix]
(fn [username] (str greeting-prefix ", " username)))
(load-file "testing.clj")
(make-greeter "Hello")
(def hello-greeter (make-greeter "Hello"))
(hello-greeter "Me")
((make-greeter "Hello") "Me")
exit
(def a (fn [arg1 arg2 & arg3] (+ (count arg1) (count arg2) (count arg3))))
(a \q \w \r \t)
(a "hi")
(a "hi" "wut")
(a 4 5 1 2)
(a () () ())
(a () ())
(a () () (1, 2))
(a () () '(1, 2))
(count (1 3 5))
(count '(1 3 5))
(count '(1 3 5 5))
(count (quote (1 3 5 5)))
(count [1 4])
(def a {:title "TFIOS" :author "John Green"})
a
(a :author)
(def a {::title "TFIOS" ::author "John Green"})
(a ::title)
::tile
(::title a)
(defrecord book (title author))
(def a (book. "TFIOS" "John Green"))
a
(def a (->book "TFIOS" "John Green"))
a
(a :book)
'(a :book)
(:book a)
(::book a)
(:title a)
(#{} 1 2)
(load-file "testing.clj")
(ellipsize "The quick brown fox jumps over")
(doc split)
(load-file "testing.clj")
(ellipsize "The quick brown fox jumps over")
(load-file "testing.clj")
(ellipsize "The quick brown fox jumps over")
(load-file "testing.clj")
(ellipsize "The quick brown fox jumps over")
(load-file "testing.clj")
(ellipsize "The quick brown fox jumps over")
(load-file "testing.clj")
(ellipsize "The quick brown fox jumps over")
(load-file "testing.clj")
(ellipsize "The quick brown fox jumps over")
(load-file "testing.clj")
(ellipsize "The quick brown fox jumps over")
(load-file "testing.clj")
(ellipsize "The quick brown fox jumps over")
(load-file "testing.clj")
(ellipsize "The quick brown fox jumps over")
(println (ellipsize "The quick brown fox jumps over"))
(load-file "testing.clj")
(println (ellipsize "The quick brown fox jumps over"))
(ellipsize "The quick brown fox jumps over")
(println (ellipsize "The quick brown fox jumps over"))
(load-file "testing.clj")
(ellipsize "The quick brown fox jumps over")
(load-file "testing.clj")
(ellipsize "The quick brown fox jumps over")
(load-file "testing.clj")
(ellipsize "The quick brown fox jumps over")
(load-file "testing.clj")
(ellipsize "The quick brown fox jumps over")
(load-file "testing.clj")
(ellipsize "The quick brown fox jumps over")
(ellipsize "The quick br")
(ellipsize "Th")
(load-file "testing.clj")
(ellipsize "The quick brown fox jumps over")
(ellipsize "The quick br")
(ellipsize "The quick brown")
(ellipsize "The quick brown fox")
(load-file "testing.clj")
(ellipsize "The quick brown fox")
(ellipsize "The quick brown")
(load-file "testing.clj")
(ellipsize "The quick brown")
(load-file "testing.clj")
(ellipsize "The quick brown")
(ellipsize "The quick brown fox")
(load-file "testing.clj")
(require 'clojure.string)
(string/split "What is This")
(clojure.string/split "What is This")
(doc clojure.string/split)
(doc require)
(require '[clojure.string as str])
(require '[clojure.string :as str])
(require '(clojure [string :as str]))
(str/split "What is the meaning of this" #"\W+")
(str/split "What is the meaning of this" #"\s+")
(load-file "testing.clj")
(ellipsize "The quick brown fox jumps)
")
(load-file "testing.clj")
(def foo 10)
(resolve foo)
(resolve 'foo)
(resolve 'split)
(in-ns 'myapp)
(clojure.core/refer 'clojure.core)
(take 10 (examples.introduction/fibs))
(require 'examples.introduction)
(take 10 (examples.introduction/fibs))
(take 10 examples.introduction/fibs)
(take 10 fibs)
(in-ns newnamespace)
(in-ns 'newnamespace)
(import '(examples introduction))
(use)
(clojure.core/refer 'clojure.core)
(import '(examples introduction))
(use '(examples introduction))
(doc use)
(doc require)
(load-file 
"src/examples/exploring.clj")
(load-file "src/examples/exploring.clj")
(ns user)
(ns myapp)
(ns examples.exploring
(:require [clojure.string :as str])
(:import (java.io File)))
(in-ns 'user)
(find-doc "ns-")
(doc ns)
(load-file 'examples.introduction)
(load-file "src/examples/introduction")
(load-file "src/examples/exploring.clj")
(date "me" "you
" "noone")
(examples.exploring/date "you" "me" "noone")
(load-file "testing.clj")
(. Math PI)
(new java.util.Random)
(doc toString)
(doc str)
(def rnd (new java.util.Random))
(. rnd nextInt)
(doc java.util.Random)
(javadoc java.util.Random)
(javadoc java.net.URL)
(defn say-hello [name] (println "Hi there, " name "!") (name))
(println (say-hello "me"))
(println '(say-hello "me"))
(println (say-hello "me"))
(say-hello "me")
(defn say-hello [name] (println "Hi there, " name "!") '(name))
(say-hello "me")
(defn say-hello [name] (println "Hi there, " name "!") name)
(say-hello "me")
(println "hi, " (say-hello "me"))
