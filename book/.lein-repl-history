(update-in (note.Note. :D# 4 1/2) [:octave] inc)
(update-in (note.Note. :D# 4 1/2) [:duration] inc)
(assoc (note.Note. :D# 4 1/2) :pitch C)
(doc assoc)
(assoc (note.Note. :D# 4 1/2) :pitch 'C)
(assoc (note.Note. :D# 4 1/2) :pitch :C)
(assoc (note.Note. :D# 4 1/2) :wow-factor :C)
(use :reload 'note)
(doc defrecord)
(/ 1 2)
(/ 1.0 2)
(float)
(float 1)
(use :reload 'note)
(doc aget)
(doc get)
(get [1 2 3] 0)
(aget [1 2 3] 0)
(doc doseq)
(use :reload 'note)
(def close-encounters [(->Note
(->Note
-> #'user/close-encounters
:D
:E
:C
:G
3
2
1/2)
1/2)])
(use :reload 'note)
(perform close-encounters)
(map #(update-in % [:octave] inc) close-encounters)
(use :reload 'note)
(map #(update-in % [:octave] inc) close-encounters)
(doc map)
(update-in (->Note :D 3 1/2) [:octave] inc)
(use :reload 'note)
(map #(update-in % [:octave] inc) close-encounters)
(use :reload 'note)
(map #(update-in % [:octave] inc) close-encounters)
(use :reload 'note)
(map #(update-in % [:octave] inc) close-encounters)
(map '(1 2 3) inc)
(map inc )
(map inc '(1 2 3))
(map #(update-in % [:octave] inc) '((->Note :D 3 1/2))))
(map #(update-in % [:octave] inc) '((->Note :D 3 1/2)))
(map #(update-in % [:octave] inc) [(->Note :D 3 1/2)])
(require [examples.midi :as midi])
(require [examples.datatypes.midi :as midi])
(require [examples.midi :as midi])
(require 'examples.midi)
(require [examples.midi])
(require '(examples.midi))
(require '[examples.midi])
(require '[examples.midi :as midi])
(require '[examples.midi])
(require '[examples.midi :as midi])
(require '(examples [midi :as midi])))
(require '(examples [midi :as midi]))
(use 'examples.midi)
(use  'examples.midi)
(require '[examples [midi :as midi]])
(midi.Note :D 2 1/2)
(midi.Note. :D 2 1/2)
(examples.midi.Note. :D 2 1/2)
(->Note. :D 2 1/2)
(->Note :D 2 1/2)
(midi/perform (->Note :D 2 1/2))
(doc reify)
(doc repeat)
(doc import)
(doc let)
(let [n (rand-int 100)] (repeat 5 n))
(doc rand-int)
(doc rand-float)
(find-doc "rand")
(doc condp)
(condp = 3
3 1
4 2
3 5)
(case 1
1 5
2 6
3 7)
(doc interpose)
(doc concat)
(symbol? 'b)
(symbol? :a)
((complement dec square) 10)
((complement dec #(* % %)) 10)
(doc last)
(butlast [1 2 3 4 5])
(cons 5 [1 2 3 4])
(defn recursive-reverse [coll]
  (loop [coll coll
         res '()]
    (if (empty? coll)
      res
      (recur (butlast coll) (cons (last coll) res)))))
(recursive-reverse [1 2 3 4 5])
(def a [1 2 3 4 5])
(cons (last a) [1 2])
(cons (last a) '())
(butlast a)
(defn recursive-reverse [coll]
  (loop [coll coll
         res '()]
    (if (empty? coll)
      res
      (recur (butlast coll) (concat res (last coll))))))
(recursive-reverse [1 2 3 4 5])
(concat '() 1)
(doc concat)
(concat '() '1)
(concat '() (list 1))
(defn recursive-reverse [coll]
  (loop [coll coll
         res '()]
    (if (empty? coll)
      res
      (recur (butlast coll) (concat res (list (last coll)))))))
(recursive-reverse [1])
(= (quote (1)) (recursive-reverse [1]))
(quote (1))
(1)
(doc quote)
(seq ())
(seq '())
(seq '(1 2))
(seq (1 2))
(seq 1(1 2))
(seq '(1 2))
(doc seq)
(str :foo :bar)
(str :foo 'bar)
(str 'foo 'bar)
(doc format)
(doc interpose)
(doc join)
(doc interleave)
(doc take-nth)
(let ['(a b) '(1 2)] a)
(let [[a b] '(1 2)] a)
(let [(a b) '(1 2)] a)
(let [[a b] '(1 2)] a)
(let [{a b} '(1 2)] a)
(let [{a :a b :b} {:a 10 :b 20}] a)
(let [{:keys [a b]} {:a 10 :b 20}] a)
(let [{:keys [a b]} {:a 10 :b 20}] (+ a b))
(let [{:keys [a b] c :c} {:a 10 :b 20 :c 30}] (+ a b))
(let [{:keys [a b] c :c} {:a 10 :b 20 :c 30}] (+ a b c))
(let [{:keys [a b] c :c :or {c 40}} {:a 10 :b 20}] (+ a b c))
(let [{:keys [a b] c :c :or {c 40}} {:a 10 :b 20 :c 1}] (+ a b c))
(let [{:keys [a b c] :or {c 40}} {:a 10 :b 20 :c 1}] (+ a b c))
(let [{:keys [a b c] :or {c 40}} {:a 10 :b 20}] (+ a b c))
(let [{:keys [a b c] :or {c 50}} {:a 10 :b 20}] (+ a b c))
(let [{:keys [a b c] :or {b 12 c 50}} {:a 10 }] (+ a b c))
(let [{:keys [a b c] :or {b 12 c 50}} {:b 10 }] (+ a b c))
(let [{:keys [a b c] :or {b 12 c 50}} {:a 1 :b 10}] (+ a b c))
(doc do)
(= '(1 2) [1 2])
[map + '(1 2)]
(map + '(1 2))
(doc set!)
(find-doc "atom")
(doc compare-and-set!)
(deftype a [name])
(:name (a. "Hey"))
(defrecord a [name])
(:name (a. "Hey"))
(doc with-out-str)
(with-out-str (println "What"))
(println "what")
(with-out-str (println "What"))
(print (with-out-str (println "What")))
(print "What\n")
(print "What\newline")
(print \newline)
(print \newline \n)
(print \newline \n\a)
(print \newline \n \a)
(print \newline\n\a)
(print \newline\n\a\a\s\s\a\a\a)
(class "warfare")
(javadoc "warfare")
(. Math PI)
(Math/PI)
(class (Math/PI))
(. Math pow 2 10)
(.pow Math 2 10)
(. Math pow 1024 1/10)
(int (. Math pow 1024 1/10))
(int 2.1)
(int 2.7)
(doc round)
(doc Math/pow)
(doc list)
(list 1 2 3)
(list '1 2 3)
(list 'if 2 3)
(list if 2 3)
(defmacro unless [expr form]
(list 'if expr nil form))
(unless (= 1 2) :true :false)
(unless (= 1 2) :true)
(first '())
(if 1 2 4 5 6)
(macroexpand '(unless (= 1 2) :true))
(macroexpand '(unless (= 1 2) true))
true
(macroexpand '(unless (= 1 2) 'true))
(Class 'true)
(class 'true)
(class :true)
(class "true")
(list "if")
(list 'if)
(defmacro unless [expr form]
(list "if" expr nil form))
(unless (= 1 2) true)
(defmacro unless [expr form] (list 'if expr nil form))
(unless (= 1 2) true)
(macroexpand '(defmacro unless [expr form] (list 'if expr nil form)))
(doc defn)
(macroexpand '(defn myFunc [_] (+ 1 _)))
(doc fn)
(doc macroexpand)
(source macroexpand-1)
(source macroexpand1)
(defn unless [expr form] (list if expr nil form))
(defn unless [expr form] (list ''if expr nil form))
(macroexpand1 '(unless nil true))
(macroexpand-1 '(unless nil true))
(macroexpand '(unless nil true))
(defmacro unless [expr form] (list ''if expr nil form))
(macroexpand-1 '(unless nil true))
(macroexpand '(unless nil true))
(unless nil true)
('if)
('if 1)
('if 2)
('if 3)
('if 4)
(class 'if)
(defmacro unless [expr form] (list 'if expr nil form))
(doc ..)
(. System (getProperties))
(.. System (getProperties) (get "os.name")
)
(.. System (getProperties) (get "os.name"))
(System/getProperties/get "os.name")
(System/getProperties "os.name")
(System/getProperties )
((System/getProperties)/get "os.name")
((System/getProperties)/get "os.name"))
((System/getProperties)/get "os.name")
(. (System/getProperties) get "os.name")
(. (System/getProperties) (get "os.name"))
(doc get)
(doc .)
(. Math pow 2 20)
(. Math pow 2N 212320)
(. Math pow 2N 2120)
(. Math pow 2N 220)
(macroexpand-1 '(.. arm getHand getFinger))
(macroexpand '(.. arm getHand getFinger))
(doc and)
(macroexpand '(1 2 3))
(macroexpand '(and 1 2 3))
(macroexpand '(or 1 2 3))
(source and)
(defmacro unless [expr & forms] (list 'if expr nil '(do forms)))
(unless false (println "this") (println "and this"))
(defmacro unless [expr & forms] (list 'if expr nil (do forms)))
(unless false (println "this") (println "and this"))
(macroexpand '(unless false (println "this") (println "and this")))
(defmacro unless [expr & forms] (list 'if expr nil ('do forms)))
(macroexpand '(unless false (println "this") (println "and this")))
(defmacro unless [expr & forms] (list 'if expr nil ('do forms)))
(macroexpand '(unless false (println "this") (println "and this")))
(source when-not)
(defmacro unless [expr & forms] (list 'if expr nil (cons 'do forms)))
(macroexpand '(unless false (println "this") (println "and this")))
(unless false (println "this") (println "and this"))
(defn wn [test & body] (if test nil (do body)))
(wn false (println "this") (println "and this"))
(wn true (println "this") (println "and this"))
(wn false (println "this") (println "and this"))
(wn false (println "this") (println "and this") (println "and this"))
(do (println "this") (println "and this") (println "and this"))
(do ((println "this") (println "and this") (println "and this")))
(do '((println "this") (println "and this") (println "and this")))
(do (list (println "this") (println "and this") (println "and this")))
(do ( (println "this") (println "and this") (println "and this")))
(find-doc "list")
(doc line-seq)
(doc list)
(list [1 2 3])
(seq 1 2 3)
(seq '(1 2 3))
(doc into)
(defmacro unless [expr & body] (list 'if expr nil (list 'do body)))
(unless nil (print "1") (print 2))
(unless nil (print "1") (print 2)")"
))
(unless nil (print "1") (print "2"))
(unless nil (print "1") (print "2"))))
(macroexpand '((unless nil (print "1") (print "2"))))
(macroexpand '(unless nil (print "1") (print "2")))
(macroexpand '(and 1 2 3))
(gensym)
(gensym asdf)
(gensym "asdf")
asdf#
(gensym "asdf")
(doc `)
(doc ~)
(use :reload 'testing)
(macroexpand (chain arm getHand getFinger))
(use :reload 'testing)
(macroexpand '(chain arm getHand))
(use :reload 'testing)
(macroexpand '(chain arm getHand))
(macroexpand '(chain arm getHand getFinger))
(source ..)
(source ~@)
(doc ~@)
(doc '~@)
(doc '~)
(doc "~")
(source chain)
(source ~@)
(use :reload 'testing)
(chain arm getHand getFinger get Nail)
(macroexpand '(chain arm getHand getFinger getNail))
(doc time)
(source time)
(chain System nanoTime)
(source time)
(System/nanoTime)
(. System nanoTime)
(.nanoTime System)
(use :reload 'testing)
(bench (+ 1 2))
(macroexpand (bench (+ 1 2)))
(macroexpand '(bench (+ 1 2)))
(System.getProperties)
(System/getProperties)
(System.getProperties.get "os.name"))
(System.getProperties.get "os.name")
(System.getProperties/get "os.name")
(bench (Math/pow 2 200))
(doc start)
(doc result)
(use :reload 'testig)
(use :reload 'testing)
(bench (+ 1 2))
(macroexpand '(bench (+ 1 2)))
(bench (+ 1 2))
(use :reload 'testing)
(let [a 1 b 2] (bench (+ a b)))
`foo#
(gensym "fo")
(require '[examples.macros :as mac])
(macroexpand '(mac/evil-bench (+ 1 2)))
(mac/bench-fn +)
(mac/bench-fn (+ 1 2 3))
(mac/bench-fn -)
(mac/bench-fn +)
(mac/bench-fn if)
(mac/bench-fn +)
(mac/bench-fn #(+ 1 2))
(mac/bench-fn #(bench (+ 1 2)))
(mac/bench-fn #(= 1 1))
(source comment)
(source defn)
(source defmacro)
(doc defmacro)
(doc create-struct)
(def person (create-struct :first-name :last-name))
(source defstruct)
(defstruct person [first-name last-name])
(defstruct person [:first-name :last-name])
(source defrecord)
(defn def-test [x] (def a x) a)
(def-test 1)
(def-test 2)
(def-test 3)
@a
a
(def-test 3)
a
(def-test 4)
a
(defn defst [name & keys] (def name (apply create-struct keys)))
(defn defst [nae & keys] (def nae (apply create-struct keys)))
(defst person :first-name :last-name)
(class nae)
(defmacro decl
([x] `(def ~x))
([x & more] `(do (def x) (decl ~@more))))
(decl a b c)
(macroexpand '(decl a b c))
a
b
c
(defmacro decl
([x] `(def ~x))
([x & more] `(do (def ~x) (decl ~@more))))
(decl a b c)
a
b
c
(decl a b c d e)
d
e
(source declare)
((fn [x] `(def ~x)) 'a)
((fn [x] `(def ~x)) 'asd)
asd
(do ((fn [x] `(def ~x)) 'asd))
(class (fn [x] `(def ~x)) 'asd))
(class ((fn [x] `(def ~x)) 'asd))
(class (cons 1 [1 2]))
(doc execute)
(source declare)
(macroexpand '(#(list 'def %)))
(doc cons)
(class (#(list 'def %) afg))
(class (#(list 'def %) 'afg))
(defmacro decl [& names]
`(do ~@(map (fn [x] `(def ~x)) names)))
(decl q w e r)
q
w
e
r
t
(macroexpand '(decl q w e))
Math/PI
(Math/PI)
(doc set!)
(source lazy-seq)
(macroexpand '(lazy-seq [1 2 3]))
(doc delay)
(source delay)
(def slow-calc (delay (. Thread sleep 500) "done!"))
(slow-calc)
slow-calc
(doc force)
@slow-calc
(doc let)
(doc dosync)
(source dosync)
(doc sync)
(source sync)
(println *out*)
(doc assert)
(source assert)
(seq? 1)
(seq? [1])
(seq? '(1))
(doc seq?)
(seq? {1})
(seq? #{1})
(doc list?)
(def [x & more] (class more))
(def thi [x & more] (class more))
(defn thi [x & more] (class more))
(thi 12 21 41)
(find-doc "array")
(doc format)
(deftype a [name title])
(def b (a. "TFIOS" "John"))
(:name b)
(b :name)
(.name b)
(. b name)
(b/name)
b/name
(defrecord a [title book])
(def b (a. "John" TFIOS"))
)
(def b (a. "John" "TFIOS"))
(.title b)
(:title b)
(. b title)
(defprotocol Award
  (present [this recipient]))
(deftype Razzie [category]
  Award
  (present [this recipient]
    (print (format "You're really the %s, %s... sorry." 
                   (.category this)
                   (recipient)))))
(with-out-str (present (Razzie. "Worst Picture") "Final Destination 5"))
